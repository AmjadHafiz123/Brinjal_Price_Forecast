# -*- coding: utf-8 -*-
"""cabbage.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cVPYLxXczXcUcW_kG7otckcZD9QG68pC
"""

import pandas as pd
import numpy as np
import lightgbm as lgb
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error, mean_absolute_error
from datetime import timedelta

# Load uploaded file
df = pd.read_csv('cabbage-price.csv')

# Expect only one column: 'price'
if 'price' not in df.columns:
    raise ValueError("CSV must contain only a 'price' column with no date column.")

# Generate dates starting from 2023-06-01
start_date = pd.to_datetime("2023-06-01")
df['date'] = pd.date_range(start=start_date, periods=len(df), freq='D')
df = df.set_index('date')

# Reindex to include all calendar days (e.g., weekends)
full_index = pd.date_range(start=df.index.min(), end=df.index.max(), freq='D')
df = df.reindex(full_index)
df.index.name = 'date'

# Forward-fill missing price values
df['price'] = df['price'].ffill()

# Lag features (past 7 days)
for lag in range(1, 8):
    df[f'lag_{lag}'] = df['price'].shift(lag)

# Optional extra features (improve model if needed)
# df['rolling_mean_3'] = df['price'].rolling(3).mean()
# df['diff_1'] = df['price'].diff()

# Time-based features
df['dayofweek'] = df.index.dayofweek
df['month'] = df.index.month

# Drop rows with NaN
df = df.dropna()

# Save as pickle
df.to_pickle("preprocessed_cabbage_data.pkl")

# Train-test split
train = df.iloc[:-7]
test = df.iloc[-7:]

X_train = train.drop(columns='price')
y_train = train['price']
X_test = test.drop(columns='price')
y_test = test['price']

# Train LightGBM
model = lgb.LGBMRegressor(min_gain_to_split=0, min_data_in_leaf=1, force_row_wise=True)
model.fit(X_train, y_train)

# Evaluate model
y_pred = model.predict(X_test)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
mae = mean_absolute_error(y_test, y_pred)
print(f'RMSE: {rmse:.2f}, MAE: {mae:.2f}')

# Forecast function with KeyError fix
def forecast_price(start_date_str, end_date_str):
    start_date = pd.to_datetime(start_date_str)
    end_date = pd.to_datetime(end_date_str)
    forecast_dates = pd.date_range(start=start_date, end=end_date, freq='D')
    forecast_df = df.copy()

    predictions = []
    last_price = forecast_df['price'].iloc[-1]

    # Precompute baseline model MAE
    base_mae = mae if mae > 0 else 1  # avoid division by 0

    for date in forecast_dates:
        if date not in forecast_df.index:
            forecast_df.loc[date] = np.nan

            # Lag features
            for lag in range(1, 8):
                lag_date = date - timedelta(days=lag)
                if lag_date in forecast_df.index and pd.notna(forecast_df.loc[lag_date, 'price']):
                    forecast_df.loc[date, f'lag_{lag}'] = forecast_df.loc[lag_date, 'price']
                else:
                    forecast_df.loc[date, f'lag_{lag}'] = forecast_df['price'].ffill().iloc[-1]

            forecast_df.loc[date, 'dayofweek'] = date.dayofweek
            forecast_df.loc[date, 'month'] = date.month

            input_features = [f'lag_{i}' for i in range(1, 8)] + ['dayofweek', 'month']
            input_row = forecast_df.loc[date][input_features]

            predicted_price = model.predict([input_row])[0]
            forecast_df.loc[date, 'price'] = predicted_price

            # Trend direction
            priceDiff = predicted_price - last_price
            trend = (
                "up" if priceDiff > 0.1 else
                "down" if priceDiff < -0.1 else
                "stable"
            )

            # Confidence based on change vs MAE
            confidence_raw = 1 - (abs(priceDiff) / (base_mae * 2))
            confidence_clamped = max(0.5, min(0.95, round(confidence_raw, 2)))

            predictions.append({
                "date": date.strftime("%Y-%m-%d"),
                "price": round(predicted_price * 100) / 100,
                "trend": trend,
                "confidence": confidence_clamped
            })

            last_price = predicted_price

    return predictions


# Example usage
future = forecast_price('2025-07-12', '2025-07-15')
for entry in future:
    print(f"{entry['date']}: Price = {entry['price']:.2f}, Trend = {entry['trend']}, Confidence = {entry['confidence']:.2f}")


# Plot result
# Extract dates and prices from forecast result
dates = [pd.to_datetime(entry['date']) for entry in future]
preds = [entry['price'] for entry in future]

# Plot
plt.figure(figsize=(10, 5))
plt.plot(df.index, df['price'], label='Historical Price', color='blue')
plt.plot(dates, preds, label='Forecast', marker='o', linestyle='--', color='orange')
plt.legend()
plt.title('Cabbage Price Forecast')
plt.xlabel('Date')
plt.ylabel('Price')
plt.grid(True)
plt.tight_layout()
plt.show()

import joblib
joblib.dump(model, 'cabbage_model.pkl')